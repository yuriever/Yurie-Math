(* ::Package:: *)

(* ::Section:: *)
(*Begin*)


BeginPackage["Yurie`Math`Unstable`"];


Needs["Yurie`Math`"];

Needs["Lacia`Base`"];


(* ::Section:: *)
(*Public*)


multiGammaPoleAnalysis::usage =
    "analyse the poles of specified variables from a product of Gamma factors.";


$multiGammaPoleAnalysisNewSymbolHead::usage =
    "head of new symbol generated by gammaPoleAnalysis.";


(* ::Section:: *)
(*Private*)


(* ::Subsection:: *)
(*Begin*)


Begin["`Private`"];


(* ::Subsection:: *)
(*Constant*)


$multiGammaPoleAnalysisNewSymbolHead = "n";


(* ::Subsection:: *)
(*Main*)


multiGammaPoleAnalysis::nonlinear =
    "the arguments of Gamma factors are nonlinear with respect to the variables.";

multiGammaPoleAnalysis[vars__][expr:(_Times|_multiGamma)] :=
    Module[ {mgdata,result,mgdataPinched,pinchingData},
        mgdata =
            getMultiGammaData[expr];
        If[ !multiGammaDataLinearQ[vars][mgdata],
            Message[multiGammaPoleAnalysis::nonlinear];
            result = expr,
            (*Else*)
            mgdataPinched =
                nestedMultiGammaDataFromPolePinching[vars][mgdata];
            result =
                getMultiGammaListFromNestedMultiGammaData[mgdataPinched];
            pinchingData =
                getPinchingDataFromNestedMultiGammaData[mgdataPinched]
        ];
        CellPrint@ExpressionCell["Pole pinching:","Output"];
        CellPrint@ExpressionCell[pinchingData,"Output"];
        result
    ];


(* ::Subsection:: *)
(*Helper*)


(* ::Text:: *)
(*get multiGamma data*)


getMultiGammaData[mg_multiGamma] :=
    mg//gammaPoleAnalysisPreprocess//multiGammaToMultiGammaData;


gammaPoleAnalysisPreprocess[mg_multiGamma] :=
    Map[Simplify/*Expand,mg,{2}];


multiGammaToMultiGammaData[mg_multiGamma] :=
    Map[<|"gammaFactor"->#,"position"->numeratorOrDenominator[mg,#]|>&,mg,{2}]//Apply[List]//Flatten;


numeratorOrDenominator[mg_,g_] :=
    3-2*Position[mg,g,{2}][[1,1]];


(* ::Text:: *)
(*check linearity*)


multiGammaDataLinearQ[vars__][mgdata_] :=
    mgdata//Query[All,"gammaFactor",linearQ[vars]]//AllTrue[#,TrueQ]&;


linearQ[vars__][expr_] :=
    PolynomialQ[expr,{vars}]&&
        Max@Total[GroebnerBasis`DistributedTermsList[expr,vars][[1,All,1]],{2}]<=1;


(* ::Text:: *)
(*pinch poles*)


nestedMultiGammaDataFromPolePinching[var_][mgdata_] :=
    newMultiGammaDataFromPolePinching[var][mgdata];

nestedMultiGammaDataFromPolePinching[var1_,var2__][mgdata_] :=
    newMultiGammaDataFromPolePinching[var1][mgdata]//
        Query[<|#,"newMultiGamma"->Map[nestedMultiGammaDataFromPolePinching[var2],#newMultiGamma]|>&];


newMultiGammaDataFromPolePinching[var_][mgdata_] :=
    Module[ {right,left,rest,pinchingList},
        {right,left,rest} = {
            gammaFactorWithRightPole[var][mgdata],
            gammaFactorWithLeftPole[var][mgdata],
            gammaFactorWithoutPole[var][mgdata]
        };
        pinchingList =
            Outer[pairPolePinching[var],right,left]//Flatten;
        <|
            "newMultiGamma"->(
                pinchingList//Query[Select[#pinched===True&]]//Map[Join[rest,{#}]&]
            ),
            "pinchingFailure"->(
                pinchingList//Query[Select[#pinched===False&]]
            )
        |>
    ];


gammaFactorWithRightPole[var_][mgdata_] :=
    mgdata//Query[Select[#position===1&&Coefficient[#gammaFactor,var]<0&]]

gammaFactorWithLeftPole[var_][mgdata_] :=
    mgdata//Query[Select[#position===1&&Coefficient[#gammaFactor,var]>0&]]

gammaFactorWithoutPole[var_][mgdata_] :=
    mgdata//Query[Select[#position===1&&Coefficient[#gammaFactor,var]===0||#position===-1&]]


pairPolePinching[var_][right_,left_] :=
    Module[ {gammaFactorChild},
        gammaFactorChild =
            right["gammaFactor"]+left["gammaFactor"]+Unique[$multiGammaPoleAnalysisNewSymbolHead];
        If[ Coefficient[gammaFactorChild,var]===0,
            <|
                "gammaFactor"->gammaFactorChild,
                "position"->1,
                "gammaFactorParent"->KeyDrop["position"][{right,left}],
                "pinched"->True
            |>,
            (*Else*)
            <|
                "gammaFactorParent"->KeyDrop["position"][{right,left}],
                "pinched"->False
            |>
        ]
    ];


(* ::Text:: *)
(*analyse the result*)


getMultiGammaListFromNestedMultiGammaData[mgdataNested_] :=
    Module[ {mgList},
        mgList =
            mgdataNested//Query["newMultiGamma"];
        Map[
            If[ !KeyExistsQ[#,"newMultiGamma"],
                multiGammaDataToMultiGamma[#],
                (*Else*)
                getMultiGammaListFromNestedMultiGammaData[#]
            ]&,
            mgList
        ]
    ];


multiGammaDataToMultiGamma[mgdata_] :=
    mgdata//Query[GroupBy[#position&],All,#gammaFactor&]//Values//Apply[multiGamma];


getPinchingDataFromNestedMultiGammaData[mgdataNested_] :=
    Module[ {mgList},
        mgList =
            mgdataNested//Query["newMultiGamma"];
        Map[
            If[ !KeyExistsQ[#,"newMultiGamma"],
                multiGammaDataToPinchingData[#],
                (*Else*)
                getPinchingDataFromNestedMultiGammaData[#]
            ]&,
            mgList
        ]
    ];


multiGammaDataToPinchingData[mgdata_] :=
    mgdata//Query[Select[KeyExistsQ["gammaFactorParent"]]]//
        Query[All,<|"child"->#gammaFactor,"parent1"->#gammaFactorParent[[1,"gammaFactor"]],"parent2"->#gammaFactorParent[[2,"gammaFactor"]]|>&]


(* ::Subsection:: *)
(*Y-system*)


YSystem::usage =
    "Y system.";

YSystemEquation::usage =
    "Y system.";


(*equations of Y system*)

Format[YSystem[u_,m_,ind_],TraditionalForm] :=
    Subsuperscript["sysY",m,Row[{"(",ind,")"}]][u];

YSystemEquation[u_,m_,cartan_?MatrixQ] :=
    Module[ {ind,$$ind},
        Table[
            YSystem[u-1,m,ind] YSystem[u+1,m,ind]==
                (1+1/YSystem[u,m-1,ind])(1+1/YSystem[u,m+1,ind])*
                    Product[1+YSystem[u,m,$$ind],{$$ind,sysYEquationProductRange[cartan,ind]}],
            {ind,Length@cartan}
        ]
    ];

sysYEquationProductRange[cartan_?MatrixQ,ind_Integer] :=
    Position[cartan[[ind]],-1]//Flatten;


(* ::Subsection:: *)
(*End*)


End[];


(* ::Section:: *)
(*End*)


EndPackage[];
